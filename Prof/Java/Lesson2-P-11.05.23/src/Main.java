import Cars.*;
import array.ArrayWorking;

public class Main {

    /*План занятия
    * - Наследование
    * - Интерфейсы*/

    /*Теория
    * Интерфейсы относятся к классам(типам), но при этом они абсолютно абстрактные, то есть имеют только абстрактные методы.
    * Интерфейс также относится к программированию по контракту, т.е обязует своего наследника реализовать определенный
    * функционал.
    *
    * --> В Java множественное наследование (от нескольких классов) невозможно, но при этом все классы наследуются от Object
    *
    * --> Интерфейсы (абсолютно абстрактные классы) нужны для реализации множественного наследования в Java, то есть
    * унаследоваться от неск классов нельзя по причине возможного возникновения конфликта между данными класса, например:
    * class Cars.Car{
    * void drive (){
    * System.out.println("speed: 180")
    * }
    * }
    *
    * class bike{
    * void drive(){
    * System.out.println("speed: 100")
    * }
    * }
    *
    * Если унаследоваться от класса Cars.Car и Bike, то по факту дочерний класс получит метод drive от обоих родителей и
    * возникнет конфликт.
    *
    * Чтобы избежать этого, множественное наследование реализовано через интерфейсы, т.е даже если в классе потомке
    * будут методы с такими же названиями, то программирование по контракту обяжет потомка сам-но реализовать этот метод
    * и компиллятор будет знать, к какой реализации ему обращаться.
    *
    * ОПРЕДЕЛЕНИЕ ИНТЕРФЕЙСА
    *
    * В абстрактном классе должен быть хотя бы 1 абстрактный метод
    * В интерфейсе все методы абстрактные
    *
    * В интфейсе могут храниться константные final переменные
    * Чтобы определить интерфейс нужно воспользоваться словом interface и в теле класса указать абстрактные методы, т.е
    * единственное отличие интерфейса от класса в ключевом слове и в том, что все методы интерфейса абстрактные. Для
    * наследования от интерфейса указывается слово implement, если нужно реализовать(унаследовать) несколько интерфейсов,
    * они указываются через запятую, например:
    * class Worker extends Human implements Runnable, ActionListener{
    *
    * }
    *
    * Клас Worker наследуется от класса Human и реализует интерфейс Runnable и ActionListener.
    *
    * _____________________________________________
    *
    * Повторение --> Передача функционала вощможна не только ср-вами наследования, но и ср-вами создания класса,
    * т.е при создании объекта мы также передаем функционал класса. такой прием называется композицией.
    * ЕСЛИ ЕСТЬ ВОЗМОЖНОСТЬ НЕ ПОЛЬЗОВАТЬСЯ НАСЛЕДОВАНИЕМ, НУЖНО ПОЛЬЗОВАТЬСЯ КОМПОЗИЦИЕЙ.
    * Композиция --> создание экземпляра объекта в методе мейн
    * Агрегация и композиция - ПОЧИТАТЬ ОБ ЭТОМ
    *
    * ______________________________________________
    *
    * Иногда нужно запретить изменять класс, метод или переменную. Для этого используем модификатор final. final --> константа
    * Указывая переменную с мод final мы запр ее изменять, метод запр переопределять, клас запр наследовать
    *
    *_________________________________________________
    *
    * Объекты можно создавать сверху вниз, потому что для шаблона родителя всегда будет требуемый функционал для его
    * потомков. Потомок - всегда более широкое понятие класса.
    *
    * Задача:  --> (ArrayWorking)
    * Реализовать класс для работы с массивом произвольного типа
    * Решение:
    * Класс делаем по аналогии с задачей из  basic для массива конкр типа, но вместо конкр типа используем Object
    * */

    /*Заметки
    * В качестве примера библиотечных классов, где представлена возможность множественного наследования, можно
    * привести класс Thread (потоки) и интерфейс Runnable  --->  эти 2 класса нужны для того, чтобы программист всегда мог
    * унаследовать функционал многопоточности, даже если у его класса уже есть родитель*/

    /**/
    // static final int CONST; // --> ример константной переменной
    public static void main(String[] args) {
        BMW bmw = new BMW("X5"); // -->
        bmw.drive();
        bmw.turnOn();
        Lamborghini lamborghini = new Lamborghini("diablo");
        lamborghini.drive();
        lamborghini.turnOn();
        lamborghini.fly();

        Car car = new Car("Mazerratti") {           // --> Анонимный класс -- реализация контракта на месте для создания абстрактного класса или интерфейса
            @Override
            public void stop() {
                System.out.println(getTitle() + " with drift");
            }

            @Override
            public void turnOn() {
                System.out.println(getTitle() + " is flying");
            }
        };
        car.drive();
        car.turnOn();
        car.stop();

        Car car1 = new Car("Жигуль") {
            @Override
            public void stop() {
                System.out.println(getTitle() + " вообще не факт");
            }

            @Override
            public void turnOn() {
                System.out.println(getTitle() + " не факт");
            }
        };
        car1.drive();
        car1.turnOn();
        car1.stop();
        System.out.println(Driveable.myClass);

        Tesla tesla = new Tesla("Тесла");
        tesla.turnOn();
        tesla.stop();
        tesla.fly();

        Car car2 = new Tesla("Тесла 2");  // -- у потомка всегда будет требуемый функционал для создания объекта родителя
        // --> Кар - понятие более узкое, с только основными характеристиками. Тесла - более широкое. Поэтому тесла может наследоваться от кара, но не кар от теслы, так как в тесле есть методы, которых нет в каре.
        // --> Потомок расширяет класс родителя, поэтому обратно по шаблону потомка нельзя создать объект родителя, т.к у родителя может не быть требуемого функционала.



        System.out.println("" + "" + tesla + "" + 2 + 1);  // --> сюда можно записать какие угодно данные из-за (Object ... arr)
        print(1,2,3,4);

        System.out.println();
        ArrayWorking arrayWorking = new ArrayWorking();
        arrayWorking.add(1);
        arrayWorking.add("Hello");
        arrayWorking.add(tesla);        // --> по умолчанию выведет в формате хеш-кода. Чтобы было адекватно, нужно в тесле создать метод toString
        arrayWorking.add(56);

    }

    /**
     * В методе при получении произвольного кол-ва параметров создается массив, в котором они хранятся (тут: массив arr)
     * (int ... arr)  --> преобразоввать в массив
     * @param arr  -- полученный массив
     *             ____________
     *                public static void print(int ... arr){ // позволяет принимать произвольное кол-во параметров и преобразует их в массив
     *         for (int i = 0; i < arr.length; i++) {
     *             System.out.print(arr[i] + "");
     *         }
     *     }_______________________
     *
     * @ВАЖНО: Если прописываем (Object ... arr) --> то наш вывод обработает все типы данных, потому что Object обрабатывает все
     */
    public static void print(Object ... arr){ // позволяет принимать произвольное кол-во параметров и преобразует их в массив
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i] + "");
        }
    }
}