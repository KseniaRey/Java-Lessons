

public class Main {

    /*
    План занятия
    1) Работа со строками
    2) Знакомство с классами StringBuilder и StringBuffer
    3) Практика
     */

    /*
    Теория
    Строка - это набор(массив) символов. В языках высокого уровня для работы со строками существуют классы, в таких классах
    описан алгоритм работы с набором(массивом) символов. У каждого алгоритма есть свои преимущества и свои недостатки, поэтому
    достаточно часто таких классов несколько. Крайне важно знать специфику каждого класса, потому что как правило программисты
    работают со строками, поэтому вряд ли получится пройти какое-либо собеседование без четкого понимания нюансов работы
    с каждым таким классом.
    В Java есть 3 класса для работы со строками:
    1) String - это класс для которого в Java есть исключение - для него перегружен оператор =, т.е. можно создать объект
    этого класса без слова new. Особенности данного класса:
    Все его объекты хранятся в специальном пуле и если объект класса String имеет значение, которое уже есть в пуле, то в него
    просто записывается ссылка на элемент этого пула. String - иммутабельный(immutable) класс, т.е. его объекты не могут
    менять свои значения, по факту при изменении строки типа String в переменную записывается ссылка на новую строку.
    Этот класс не подходит для частных изменений переменных. В Java память освобождается сборщиком мусора(garbage collector).
    Поскольку при создании нового значения типа String в него записывается новая ссылка, то старая будет уничтожена сборщиком
    мусора, соответсвенно, если часто менять переменные типа String, то работа программы замедлится за счет частых запуском
    сборщика мусора.
    Остальные классы для работы со строками изменяемые(mutable). Классы StringBuilder и StringBuffer имеют одинаковые методы,
    которые выполняют одинаковые функции. (СПРАШИВАЮТ НА СОБЕСЕДОВАНИИ)
    2) StringBuilder - подходит для работы в однопоточной среде
    3) StringBuffer  - подходит для работы во многопоточной среде

    Так. Зачем нужен StringBuilder?
    String в Java - иммутабельный класс. StringBuilder позволяет изменить значение объекта без запуска
    Garbage Collector.


    Иммутабельный (неизменяемый, immutable) класс — это класс, который после инициализации не может
    изменить свое состояние. То есть если в коде есть ссылка на экземпляр иммутабельного класса,
    то любые изменения в нем приводят к созданию нового экземпляра.

   =====================================================================================================================
                                         То, что Влад рисовал во время урока
   =====================================================================================================================

Атомарность - выполнение операции в одно действие, как правило операции неатомарные,
т.е. требуют несколько действий для своего выполнения

Задача

В двух потоках осуществляется обработка транзакций с банковского счета, чтобы
 не возникла ситуация, что оба потока осуществляющие работу над изменением баланса, считали
 одно и то же число, необходимо выполнить синхронизацию, т.е. запретить двум потоком в одно время работать с объектом,

до операции synchronized возможно ситуация как на рисунке выше, т.е. оба потока считали 1000 г
вычитают из нее сумму покупки, таким образом результат будет некорректный, после операции synchronized
такая ситуация невозможна, если один поток начал работу с объектом, другие не смогут работать
с ним пока он не завершит свою работу.
     */




    /*
    Заметки

   =====================================================================================================================
                                         Найдено самостоятельно на скиллбокс
   =====================================================================================================================
   Как создать свой поток в Java

Для этого есть класс Thread — это поток, только на уровне кода. Создать их можно сколько угодно, но
одновременно будет выполняться столько, сколько поддерживает ваша система.

Интерфейс Runnable — это задача, которую выполняет поток, то есть код.
Интерфейс содержит основной метод run() — в нём и находится точка входа и логика исполняемого потока.

Создать поток в Java можно двумя способами.

Первый способ:

Определить класс — наследник класса Thread и переопределить метод run().
Создать экземпляр своего класса и вызвать метод start().

class MyThread extends Thread{
    @Override
    public void run(){
        System.out.println("Hello, I’m " + Thread.currentThread());
    }
}
public class Main{
    public static void main(String[] args){
        MyThread myThread = new MyThread();
        myThread.start();
    }
}
Вывод: Hello, I’m Thread[Thread-0,5,main]

Обратите внимание: если на экземпляре класса Thread вместо метода start() вызвать run(), то код,
 написанный для другого потока, отлично выполнится, но выполнит его тот же тред, который и вызвал
 этот метод, а новый запущен не будет! Поэтому нужно пользоваться методом start().

Второй способ:

Реализовать интерфейс Runnable и метод run().
Создать экземпляр Thread и передать в конструктор свой Runnable (экземпляр класса, реализующий этот интерфейс).
class MyThread implements Runnable{
    @Override
    public void run(){
        System.out.print("Hello, I’m " + Thread.currentThread().getName());
    }
}

public class Main{
    public static void main(String[] args){
        // Первый параметр: экземпляр Runnable
        // Второй параметр: своё имя (необязательно)
        Thread myThread = new Thread(new MyThread(), "Leo");
        myThread.start();
    }
}
Вывод: Hello, I’m Leo

Второй вариант лучше — он более гибкий. Например, если бы MyThread уже наследовал какой-либо класс, то было бы невозможно пойти первым путём, так как Java не поддерживает множественное наследование.

     */

    /*
    Задачи со звездочкой
    Сделать класс по аналоги со String, т.е. неизменяемый и класс по аналогии со StringBuilder - изменяемый для обработки
    массива типа char.
     */




    String str = "Hello";
    static StringBuilder stringBuilder = new StringBuilder();  // Объекты классов
    static StringBuffer stringBuffer = new StringBuffer();  // этот синхронизированный, закрытый. Для многопоточной системе, чтобы
    // не слить два потока в 1 и не получить некорректные значение
    public static void main(String[] args) {

        stringBuilder.append("Hello, StringBuilder");
        System.out.println(stringBuilder);
        stringBuilder.insert(5, "cool");
        System.out.println(stringBuilder);
        stringBuilder.replace(5, 7, "BB");
        System.out.println(stringBuilder);
        stringBuilder.deleteCharAt(5);
        System.out.println(stringBuilder);

        stringBuffer.append("Hello, StringBuffer");
        System.out.println(stringBuffer);
        stringBuffer.insert(10, "String");
        System.out.println(stringBuffer);
        stringBuffer.replace(15, 18, "Bye");
        System.out.println(stringBuffer);
        stringBuffer.deleteCharAt(3);
        System.out.println(stringBuffer);

        System.out.println(stringBuilder.charAt(11));

        //Ниже работа с продленнкой. Класс MyString тоже делали с продленкой

//        try {
//            display(7);
//        }
//        catch (MyException ex){
//            ex.printStackTrace();
//        }
//        finally {
//            System.out.println("Проверили конструкцию try-catch-finally");
//        }

        char[] chars = {'h','e', 'l', 'l', 'o'};
        MyString myString = new MyString(chars);
        myString.add('a');
        myString.add('b');
        myString.add('c');
        myString.display();

        myString.addString(chars);
        myString.display();


    }

    public static void display(int a) throws MyException {
        if(a > 5){
            throw new MyException("Ошибка. Число больше 5");
        }
    }
}