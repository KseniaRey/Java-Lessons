/*
 * Теория
 * Сигнатура метода содержит кроме названия тип метода, аргумены, передаваемые методу и раположение метода в памяти*
 * (static или не static) и модификатор доступа.
 * Тип метода:
 * void - процедура (ничего не возвращает в точку вызова)
 * тип переменной (например, int) - возвращает значение типа в точку вызова (функция)
 * вообще не указан тип, имеет название такое же, как класс
 *
 * ---статический элемент находися в Метаспейсе.---
 *  //______________________________________==========================================_______________________________________________________
    //                                                 МОДИФИКАТОРЫ ДОСТУПА
    //______________________________________==========================================_______________________________________________________
    *   Access:
    * Static - находится в классе (Metaspace), нестатические переменные находятся в объекте, т.е при создании объекта нестатические переменные
    * дублируются в объект (в области памяти Heap, куча).
    *   Модификаторы доступа (access modifiers):
    * В Java их 4:
        * private               // доступ только в пределах класс
        * default(пустой)       // это обычные пустые примитивные переменные, доступ только в пакете
        * protected             // доступ в пределах пакета и классах наследниках
        * public                // доступ везде
        * final                 // константа, внесение изменений запрещено
 *
 * Задача: показать работу всех 4 модификаторов доступа в Java
 * Решение: создадим 2 пакета: packageA, packageB. В каждом из них создадим по 2 класса -- A, B, C, D
 *
 * Модификаторы доступа служат для инкапсуляции(сокрытия) переменных - один из основных приемов ООП / in capsule -> в капсулу, регулировать доступ
 *
 */
/*
 *  Заметки
 * Идентификатор может быть любого типа, но он должен быть уникальным
 */

/*
Теория
Преимущества метода: разбивает код на подзадачи, структурирует задачи
более читабельный код
такие участки кода можно использовать повторно

Типы в Java:
void - процедура
типизированный - функция - возвращает значение return
конструкторы - название всегда совпадает с названием класса, в кот определены

static - принадлежит классу, т е всегда будет находиться в той же области памяти, что и класс - в Metaspace. Так как он принадлежит
классу, то всегда будет иметь общий для всех объектов класс.

final - константа, т.е этот модификатор доступа запрещает вносить изменения.
Константные переменные принято называть большими буквами.

Полиморфизм(многоформие) - способ используя одно название создавать решения разных задач.
Широко применяется в бухгалтерии, логистике, продажах

Аксессоры (геттеры и сеттеры) - методы для работы с полями класса. Идея следующая: поля приватные, т.е доступ можно
получить только внутри класса, потому что мы создаем в классе метод, кот возвращает значение приватной переменной, а сам
метод делаем публичным. Через геттеры получаем значение, через сеттеры его меняем (меняем заприваченное значение)
//_______________________________________
Логические выражения
Сравнение
==  - логическое равно (сравнение)
!=  - логическое не равно
>   - больше
<   - меньше
>=  - больше либо равно
<=  - меньше либо равно

Логические выражения могут содержать несколько условий. Их можно определять
&&  - и; пример: Я учусь и преподаю - неверное утверждение, а я человек и Катя человек - верное. Чтобы получить true при объединении
условий операции && все условия должны быть одного типа: или true или false.
||  - или; пример: Мы пишем на Java или JS - true,  для того, чтобы получить true в таком выражении достаточно одного выполненного условия
^(ксор, xor)   - исключающее или\либо(самая редкая); пример: Участник лекции либо преподаватель, либо студент (допустимо только 1 условие)
*/

/*
Заметки
Для геттеров логических переменных принято писать вместо get - is -- тонкости английского языка. Например, булевое значение
* */
public class Test {
    static final int NUM = 12; // значение этой переменной мы не можем изменить
    public static void main(String[] args) {
        System.out.println("Периметр прямоугольника: " + perimeter(2,3));
        System.out.println("Периметр треугольника: " + perimeter(3,4,5));

        Car car = new Car("Mazda", 2022, 37000);
        Car car1 = new Car("BMW", 2020, 180000, true);

        System.out.println(car.getBrand());
        car.setPrice(40000);
        System.out.println(car.getPrice());

        System.out.println(car1.getBrand());
        car1.setBrand("Nissan");

//Логические выражения
        int a = 10;
        int b = 15;
        int c = 7;
        int d = 15;
        // Condition: 1 переменная больше третьей или больше второй
        System.out.println(a > c || a > b); //true, одно усл верно
        // Condition: вторая больше 1 и больше 3
        System.out.println(b > a && b < c); // true, оба усл верны
        // Condition: вторая больше 1 и меньше третьей
        System.out.println(b > a && b < c); // false,  второе условие не выполнено
        // Condition: вторая больше четвертой
        System.out.println(b > d); // false, они равны
        // Condition: вторая больше или равна 4
        System.out.println(b >= d); // true, равны
        // Condition: либо 2 либо 4 равна 15 (одна из них)
        System.out.println(b == 15 ^ d == 15); // false, равны оба
        // Condition: первая не равна 10, а третья равна 7
        System.out.println(a != 10 ^ c == 7); // true, потому что одно условие должно быть true, а второе false
        System.out.println(isEqual(10,15)); // вызов метода для сравнения 2 чисел (написан ниже)

        //Внизу будут те же задачи только вызванные с помощью функции
        //__________________________________________
        System.out.println(isMore(2,3,4,3));
        System.out.println(isBigger(3,5,7));
        System.out.println(isSecondBigger(3,7));
        System.out.println(isEqualOrBigger(6,12));
        System.out.println(isOneEqual(15,22));
    }

    /**
     * Метод сравнивает 2 значения и возвращает булевое значение
     * @param a
     * @param b
     * @return результат сравнения
     */
    public static boolean isEqual (int a, int b){
        return a == b;
    }
    //_____________________________________________________
    public static boolean isMore (int a, int b, int c, int d){
        return a > c || a > b;
    }
    public static boolean isBigger(int a, int b, int c){
        return b > a && b < c;
    }
    public static boolean isSecondBigger(int b, int d){
        return b > d;
    }
    public static boolean isEqualOrBigger(int b, int d){
        return b >= d;
    }
    public static boolean isOneEqual (int b, int d){
        return b == 15 ^ d == 15;
    }
    public static boolean isTheyNotEqual(int a, int c){
        return a != 10 ^ c == 7;
    }

    /*Задача: Создать методы для нахождения периметром (сумм сторон фигур): треугольника и прямоугольника.
    * Решение: Воспользуемся полиморфизмом и создадим 2 метода с названием perimeter и передадим в них разные параметры
    * для треуг 3, для прямоуг - 2
    * */

    /**
     * Метод для рассчета периметра прямоугольника:
     * @param a - одна сторона;
     * @param b - вторая сторона;
     * @return - сумма всех сторон
     */
        public static int perimeter(int a, int b){
            return 2*(a+b);
        }

    /**
     * Метод для рассчета периметра треугольника:
     * @param a - сторона 1;
     * @param b - сторона 2;
     * @param c - сторона 3;
     * @return - сумма всех сторон
     */
        public static int perimeter(int a, int b, int c){
            //TODO: Сделать проверку на корректность введенных данных - является ли фигура треугольником
            return a+b+c;
        }




}